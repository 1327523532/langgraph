from __future__ import annotations

import asyncio
from abc import ABC, abstractmethod
from typing import (
    Any,
    AsyncContextManager,
    AsyncIterator,
    Callable,
    Iterator,
    Sequence,
    TypedDict,
)
from typing_extensions import TypeGuard


class PubSubMessageSpec(TypedDict):
    correlation_id: str
    """Unique ID of the computation that produced this message, 1-1 mapping to
    original input message."""
    topic: str
    """String topic that namespaces this message."""
    value: Any
    """Value of the message. This is the actual data that is being published."""


class PubSubMessage(PubSubMessageSpec):
    id: str
    """Unique ID of the message. This is generated by the connection, and
    should provide a total ordering of messages."""
    published_at: str
    """ISO-8601 timestamp of when the message was published, assigned by the
    connection."""


class StreamState(TypedDict):
    next: PubSubMessage
    """The next message to process"""
    state: Any
    """Specific to each connection. State of the stream consumers immediately
    before `next` message is published."""


def is_pubsub_message(obj: Any) -> TypeGuard[PubSubMessage]:
    return (
        isinstance(obj, dict)
        and "value" in obj
        and "topic" in obj
        and "published_at" in obj
        and "correlation_id" in obj
    )


PubSubListener = Callable[[PubSubMessage, str], None]


class StreamConnectionMaker(ABC):
    @abstractmethod
    def connect(self, correlation_id: str, state: Any) -> StreamConnection:
        ...


class StreamConnection(ABC, AsyncContextManager["StreamConnection"]):
    correlation_id: str

    def __init__(self, correlation_id: str) -> None:
        self.correlation_id = correlation_id

    async def send(self, spec: PubSubMessageSpec) -> None:
        ...

    def stream(
        self,
        consumer_id: str,
        topics: Sequence[str] | None = None,
    ) -> AsyncIterator[StreamState]:
        ...


async def blah():
    async with StreamConnectionMaker().connect() as connection:
        pass


class PubSubConnection(ABC):
    def full_name(self, prefix: str, *parts: str) -> str:
        """Return the full topic name for a given prefix and topic name."""
        return ":".join(map(str, [prefix, *parts]))

    @abstractmethod
    def observe(self, prefix: str) -> Iterator[PubSubMessage]:
        """Iterate over messages for all topics under this prefix,
        without affecting listeners/iterators on each topic.
        This method waits for new messages to arrive."""
        ...

    @abstractmethod
    def iterate(
        self, prefix: str, topic: str, *, wait: bool
    ) -> Iterator[PubSubMessage]:
        """Iterate over all currently queued messages for a topic, consuming them.
        Optionally wait for new messages to arrive."""
        ...

    # TODO add aiterate() method

    @abstractmethod
    def listen(self, prefix: str, topic: str, listeners: list[PubSubListener]) -> None:
        ...

    async def alisten(
        self, prefix: str, topic: str, listeners: list[PubSubListener]
    ) -> None:
        return await asyncio.get_event_loop().run_in_executor(
            None, self.listen, prefix, topic, listeners
        )

    def inflight_start(self, prefix: str) -> None:
        ...

    def inflight_stop(self, prefix: str) -> None:
        ...

    def inflight_size(self, prefix: str) -> int:
        ...

    @abstractmethod
    def send(self, message: PubSubMessage) -> None:
        ...

    async def asend(self, message: PubSubMessage) -> None:
        return await asyncio.get_event_loop().run_in_executor(None, self.send, message)

    @abstractmethod
    def connect(self, prefix: str) -> None:
        ...

    async def aconnect(self, prefix: str) -> None:
        return await asyncio.get_event_loop().run_in_executor(
            None, self.connect, prefix
        )

    @abstractmethod
    def disconnect(self, prefix: str) -> None:
        ...

    async def adisconnect(self, prefix: str) -> None:
        return await asyncio.get_event_loop().run_in_executor(
            None, self.disconnect, prefix
        )
